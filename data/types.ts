// Code generated by translation from Zig - manual edits will be overwritten.

// Since we don't have access to the gen1 module, we'll define the necessary types here
enum Effectiveness {
  Super = 0,
  Neutral = 1,
  Resisted = 2,
  Immune = 3,
}

// Effectiveness enum values
const S = Effectiveness.Super;
const N = Effectiveness.Neutral;
const R = Effectiveness.Resisted;
const I = Effectiveness.Immune;

/**
 * Representation of a Generation I type in Pokémon.
 */
export enum Type {
  Normal = 0,
  Fighting = 1,
  Flying = 2,
  Poison = 3,
  Ground = 4,
  Rock = 5,
  Bug = 6,
  Ghost = 7,
  Fire = 8,
  Water = 9,
  Grass = 10,
  Electric = 11,
  Psychic = 12,
  Ice = 13,
  Dragon = 14,
}

const CHART: Effectiveness[][] = [
  [N, N, N, N, N, R, N, I, N, N, N, N, N, N, N], // Normal
  [S, N, R, R, N, S, R, I, N, N, N, N, R, S, N], // Fighting
  [N, S, N, N, N, R, S, N, N, N, S, R, N, N, N], // Flying
  [N, N, N, R, R, R, S, R, N, N, S, N, N, N, N], // Poison
  [N, N, I, S, N, S, R, N, S, N, R, S, N, N, N], // Ground
  [N, R, S, N, R, N, S, N, S, N, N, N, N, S, N], // Rock
  [N, R, R, S, N, N, N, R, R, N, S, N, S, N, N], // Bug
  [I, N, N, N, N, N, N, S, N, N, N, N, I, N, N], // Ghost
  [N, N, N, N, N, R, S, N, R, R, S, N, N, S, R], // Fire
  [N, N, N, N, S, S, N, N, S, R, R, N, N, N, R], // Water
  [N, N, R, R, S, S, R, N, R, S, R, N, N, N, R], // Grass
  [N, N, S, N, I, N, N, N, N, S, R, R, N, N, R], // Electric
  [N, S, N, S, N, N, N, N, N, N, N, N, R, N, N], // Psychic
  [N, N, S, N, S, N, N, N, N, R, S, N, N, R, S], // Ice
  [N, N, N, N, N, N, N, N, N, N, N, N, N, N, S], // Dragon
];

interface TypePair {
  type1: Type;
  type2: Type;
}

const PRECEDENCE: TypePair[] = [
  { type1: Type.Fire, type2: Type.Ice },
  { type1: Type.Grass, type2: Type.Water },
  { type1: Type.Water, type2: Type.Rock },
  { type1: Type.Water, type2: Type.Water },
  { type1: Type.Electric, type2: Type.Electric },
  { type1: Type.Ice, type2: Type.Ice },
  { type1: Type.Fire, type2: Type.Water },
  { type1: Type.Electric, type2: Type.Flying },
  { type1: Type.Grass, type2: Type.Ground },
  { type1: Type.Grass, type2: Type.Poison },
  { type1: Type.Grass, type2: Type.Rock },
  { type1: Type.Grass, type2: Type.Flying },
  { type1: Type.Ice, type2: Type.Water },
  { type1: Type.Ice, type2: Type.Flying },
  { type1: Type.Fighting, type2: Type.Normal },
  { type1: Type.Fighting, type2: Type.Flying },
  { type1: Type.Fighting, type2: Type.Psychic },
  { type1: Type.Fighting, type2: Type.Rock },
  { type1: Type.Fighting, type2: Type.Ice },
  { type1: Type.Poison, type2: Type.Grass },
  { type1: Type.Poison, type2: Type.Poison },
  { type1: Type.Poison, type2: Type.Bug },
  { type1: Type.Ground, type2: Type.Grass },
  { type1: Type.Ground, type2: Type.Bug },
  { type1: Type.Ground, type2: Type.Poison },
  { type1: Type.Bug, type2: Type.Flying },
  { type1: Type.Bug, type2: Type.Ghost },
  { type1: Type.Bug, type2: Type.Poison },
  { type1: Type.Electric, type2: Type.Dragon },
];

// Constants and utility functions
export const size = 15; // The number of types in this generation

/**
 * Whether or not this type is considered to be special as opposed to physical.
 */
export function special(type: Type): boolean {
  return type >= Type.Fire;
}

/**
 * The effectiveness of type t2 vs. type t1.
 */
export function effectiveness(t1: Type, t2: Type): Effectiveness {
  return CHART[t1][t2];
}

/**
 * The precedence order of Type t2 vs. Type t1.
 */
export function precedence(t1: Type, t2: Type): number {
  for (let i = 0; i < PRECEDENCE.length; i++) {
    const matchup = PRECEDENCE[i];
    if (matchup.type1 === t1 && matchup.type2 === t2) return i;
  }
  throw new Error("Unreachable");
}

/**
 * Representation of a Pokémon's typing.
 */
export interface Types {
  /** A Pokémon's primary type. */
  type1: Type;
  /** A Pokémon's secondary type (may be identical to its primary type). */
  type2: Type;
}

/**
 * Create a new Types object with default values.
 */
export function createTypes(
  type1: Type = Type.Normal,
  type2: Type = Type.Normal
): Types {
  return { type1, type2 };
}

/**
 * Whether this typing is immune to type t.
 */
export function immune(types: Types, t: Type): boolean {
  return (
    effectiveness(types.type1, t) === I || effectiveness(types.type2, t) === I
  );
}

/**
 * Whether this typing includes type t.
 */
export function includes(types: Types, t: Type): boolean {
  return types.type1 === t || types.type2 === t;
}
